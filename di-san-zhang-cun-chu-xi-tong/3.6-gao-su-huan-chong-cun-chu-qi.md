# 3.6 高速缓冲存储器

## 3.6.1 局部性原理

**时间局部性**：在最近的未来要用到的信息，很可能是现在正在使用的信息

**空间局部性**：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的

## 3.6.2 Cache的工作原理

基于局部性原理，可以把CPU目前访问的地址周围的部分数据放到Cache中。

将主存与Cache分为同样大小的块（见操作系统“分页”相关内容），**主存和Cache之间以块为单位进行数据交换**。系统访问主存时，会将这一块的内容同时复制到Cache中。

### Cache的性能分析

**命中率**H：CPU欲访问的信息已在Cache中的比率

**缺失（未命中）率**：$$M=1-H$$ 

{% hint style="info" %}
设 $$t_{c}$$为访问一次Cache所需时间， $$t_{m}$$为访问一次主存所需时间，则Cache-主存系统的平均访问时间t为

$$t=H\cdot t_{c}+(1-H)(t_{c}+t_{m})$$ 

**先访问Cache，若Cache未 命中再访问主存**

或是 $$t=H\cdot t_{c}+(1-H)t_{m}$$ 

同时访问Cache和主存，**若Cache命中则立即停止访问主存**
{% endhint %}

## 3.6.3 Cache和主存的映射方式

Cache需要设置有效位，表明此块是否有效；

Cache中设置标记，与主存块号相等，表示存储的主存块。

假设计算机的主存地址空间大小为256MB, 按字节编址，其数据Cache有8个Cache行，行长为64B。则：

### 1、全相联映射

主存块可以存放在Cache的任何位置。

![](../.gitbook/assets/quan-xiang-lian-ying-she-.png)

* $$256 \text{M} = 2^{28}$$，主存地址共28位
* Cache行与主存块大小相等， $$64 \text{B} = 2^6$$，块内地址为6位
* 主存共有块号为22位
* Cache中有一位有效位，22位标志位

#### 访存过程

1. 用所要访问的主存地址的前22位，对比Cache中所有块的标记；
2. 若标记匹配且有效位=1，则Cache命中，访问相应块内地址的单元；
3. 若未命中或有效位=0，则正常访问主存

### 2、直接映射

每个主存块只能放在特定的位置。

$$
\text{主存块在Cache中的位置} = \text{主存块号} \% \text{Cache总块数}
$$

![](../.gitbook/assets/zhi-jie-ying-she-.png)

* 本例中有8个Cache块，对8取余的实质是**取二进制的后三位**
* Cache的序号即可反映主存块的后三位，因此标记中不再记录后三位，节省空间
* 主存块号可以依此细分为**19位标记**和**3位行号**

#### 访存过程

1. 根据主存块号的后3位确定**Cache行；** 
2. 若主存块号的前19位与Cache标记匹配，且有效位=1，则Cache命中，访问相应块内地址的单元；
3. 若未命中或有效位=0，则正常访问主存

### 3、组相联映射

将Cache块分组，每个主存块只能存放到特定的分组中。当分组中有空位时，就将该主存块中的内容存入。

$$
\text{主存块在Cache中的位置} = \text{主存块号} \% \text{Cache分组数}
$$

![](../.gitbook/assets/zu-xiang-lian-ying-she-.png)

* 本例中分了4组，对4取余实际上是**取二进制的后两位**
* 同理，不记录后两位，节省标志位空间
* 主存块号可以依此细分为**20位标记**和**2位组号**

#### 访存过程

1. 根据主存块号的后2位确定所属分组号
2. 若主存块号的前20 位与分组内的某个标记匹配且有效位=1， 则Cache命中，访问相应块内地址的单元；
3. 若未命中或有效位=0，则正常访问主存

